import cv2
import os
import sys
import argparse
import pickle
from tqdm import tqdm
import math
import numpy as np
import tensorflow as tf
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'
import warnings
warnings.filterwarnings('ignore')
from keras.models import load_model
import get_faces

model_path = {128 : "models/20170512-110547/20170512-110547.h5",
              512 : "models/20180408-102900/20180408-102900.h5"}

def get_model(emb_dim):
    if not os.path.exists(
            os.path.join(os.getcwd(),
                         model_path[emb_dim])):
        print("Please download trained model!")
        return None
    print("Loading model...")
    return load_model(model_path[emb_dim])

"""pre-whitening the images before passing through the net
       is VERY important for good results"""
def prewhiten(x):
    mean = np.mean(x)
    std = np.std(x)
    std_adj = np.maximum(std, 1.0/np.sqrt(x.size))
    y = np.multiply(np.subtract(x, mean), 1/std_adj)
    return y 

"""the facenet network takes 160x160x3 sized inputs"""
input_image_size = 160

"""re-size the image for the network and apply whitening"""
def prepoc(img):
    resized_img = cv2.resize(img, 
                     (input_image_size,input_image_size),
                     interpolation=cv2.INTER_CUBIC)
    
    return prewhiten(resized_img)

def get_face_encodings(folder_path,
                       face_crops, 
                       emb_dim=512,
                       batch_size=64,
                       use_cache=False, save_cache=False):

    #check if encodings already exist for this folder
    cache_path = os.path.join(folder_path, "face_encodings.pkl")
    if use_cache:
        print("Loading cached encodings...")
        if not os.path.exists(cache_path):
            print("No cache to load!")
            return
        with open(cache_path, "rb") as f:
            face_encodings = pickle.load(f)
    else:
        print("Generating encodings for faces...")
        #load the keras model
        facenet = get_model(emb_dim)
        if facenet is None:
            return

        #preprocess all the crops
        face_crops = [prepoc(crop) for crop in face_crops]
        face_count = len(face_crops)
        face_encodings = []
        for i in tqdm(range(math.ceil(face_count/batch_size))):
            face_crops_batch = np.array(face_crops[i*batch_size:min((i+1)*batch_size, face_count)])
            face_encodings.append(facenet.predict_on_batch(face_crops_batch))

        face_encodings = np.vstack(face_encodings)

    if save_cache:
        print("Caching encodings...")
        with open(cache_path, "wb") as f:
            pickle.dump(face_encodings, f)

def parse_arguments(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "-f","--folder", type=str,
        help='folder containing photos to be processed',
        required=True)

    parser.add_argument(
        '-e', '--emb_dim', 
        type=int,
        help='size of the embedding generated by the model', 
        default='512', required=False)

    parser.add_argument('-b','--batch_size', type=int,
        help="batch_size to pass through the model",
        default=64, required=False)

    parser.add_argument('-uc', '--use_crop_cache', type=bool,
        help="use the cached results for face crops if present",
        default=False, required=False)

    parser.add_argument('-sc', '--save_crop_cache', type=bool,
        help="cache results for face crops",
        default=True, required=False)

    parser.add_argument(
        '-ue', '--use_emb_cache', type=bool,
        help="use the cached results for embeddings if present",
        default=False, required=False)

    parser.add_argument(
        '-se','--save_emb_cache', type=bool,
        help="cache results for face embeddings",
        default=True, required=False)

    return parser.parse_args(argv)

def main(args):
    face_crops = get_faces.process_folder(args.folder, args.use_crop_cache, args.save_crop_cache)
    if len(face_crops) == 0:
        return
    get_face_encodings(args.folder, 
                       face_crops, 
                       args.emb_dim,
                       args.batch_size, 
                       args.use_emb_cache, 
                       args.save_emb_cache)

if __name__ == '__main__':
    main(parse_arguments(sys.argv[1:]))